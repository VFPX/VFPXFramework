*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="vfpxsortgrid.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS vfpxsortgrid AS vfpxbasegrid OF "vfpxbaselibrary.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: createimages		&& Creates the up and down images
		*m: istag		&& Returns .T. if there's a tag on the specified field
		*m: sortgrid		&& Sorts the grid on the clicked column
		*p: cdownimage		&& The down image to use
		*p: cupimage		&& The up image to use
		*p: nheadersortablebackcolor
		*p: nheadersortedbackcolor
	*</DefinedPropArrayMethod>

	*<PropValue>
		cdownimage = 
		cupimage = 
		Name = "vfpxsortgrid"
		nheadersortablebackcolor = (rgb(255, 255, 220))
		nheadersortedbackcolor = (rgb(220, 255, 220))
		Themes = .F.
		_memberdata = <VFPData>
			<memberdata name="nheadersortablebackcolor" display="nHeaderSortableBackColor"/>
			<memberdata name="nheadersortedbackcolor" display="nHeaderSortedBackColor"/>
			<memberdata name="istag" display="IsTag"/>
			<memberdata name="sortgrid" display="SortGrid"/>
			<memberdata name="createimages" display="CreateImages"/>
			<memberdata name="cdownimage" display="cDownImage"/>
			<memberdata name="cupimage" display="cUpImage"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE createimages		&& Creates the up and down images
		This.cDownImage = addbs(sys(2023)) + 'down.bmp'
		if not file(This.cDownImage)
			text to lcImage noshow pretext 1 + 2 + 4
			424DF60000000000000076000000280000000F000000100000000
			10004000000000080000000C40E0000C40E000000000000000000
			00000000000000800000800000008080008000000080008000808
			0000080808000C0C0C0000000FF0000FF000000FFFF00FF000000
			FF00FF00FFFF0000FFFFFF00FFFFFFFFFFFFFFF0FFFFFFFFFFFFF
			FF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0FF
			FFFFF0FFFFFFF0FFFFFF000FFFFFF0FFFFF00000FFFFF0FFFF000
			0000FFFF0FFF000000000FFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFF
			FFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0F
			FFFFFFFFFFFFFF0
			endtext
			strtofile(strconv(lcImage, 16), This.cDownImage)
		endif not file(This.cDownImage)
		
		This.cUpImage = addbs(sys(2023)) + 'up.bmp'
		if not file(This.cUpImage)
			text to lcImage noshow pretext 1 + 2 + 4
			424DF60000000000000076000000280000000F00000010000
			000010004000000000080000000C40E0000C40E0000000000
			0000000000000000000000800000800000008080008000000
			0800080008080000080808000C0C0C0000000FF0000FF0000
			00FFFF00FF000000FF00FF00FFFF0000FFFFFF00FFFFFFFFF
			FFFFFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0FFFFFFFFFF
			FFFFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0FFF00000000
			0FFF0FFFF0000000FFFF0FFFFF00000FFFFF0FFFFFF000FFF
			FFF0FFFFFFF0FFFFFFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFF
			FF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0FFFFFFFFFFFFFFF0
			endtext
			strtofile(strconv(lcImage, 16), This.cUpImage)
		endif not file(This.cUpImage)
		
	ENDPROC

	PROCEDURE Init
		local lcAlias, ;
			lnSelect, ;
			lcOrder, ;
			llDescending, ;
			loColumn, ;
			loControl, ;
			loHeader, ;
			lcField
		with This
			.CreateImages()
			lcAlias  = .RecordSource
			lnSelect = select()
			select (lcAlias)
			lcOrder      = set('ORDER')
			llDescending = 'DESCENDING' $ lcOrder
			lcOrder      = getwordnum(lcOrder, 2)
			select (lnSelect)
			for each loColumn in This.Columns foxobject
				for each loControl in loColumn.Controls foxobject
					if lower(loControl.BaseClass) == 'header'
						loHeader = loControl
						exit
					endif lower(loControl.BaseClass) == 'header'
				next loControl
				lcField = upper(justext(loColumn.ControlSource))
				do case
					case not .IsTag(lcField, lcAlias)
					case lcField == lcOrder
						loHeader.BackColor = .nHeaderSortedBackColor
						loHeader.Picture   = iif(llDescending, .cUpImage, .cDownImage)
						loHeader.Tag       = lcField
					otherwise
						loHeader.BackColor = .nHeaderSortableBackColor
						loHeader.Tag       = lcField
				endcase
				bindevent(loHeader, 'Click', This, 'SortGrid')
			next loColumn
		endwith
		
	ENDPROC

	PROCEDURE istag		&& Returns .T. if there's a tag on the specified field
		lparameters tcFieldName, ;
			tcTable
		local laTags[1], ;
			llReturn
		ataginfo(laTags, '', tcTable)
		llReturn = ascan(laTags, tcFieldName, -1, -1, 1, 15) > 0
		return llReturn
		
	ENDPROC

	PROCEDURE sortgrid		&& Sorts the grid on the clicked column
		local laEvents[1], ;
			loHeader, ;
			lcField, ;
			llDescending, ;
			loColumn, ;
			loControl, ;
			llFoundColumn, ;
			llAllowCellSelection, ;
			lcTable, ;
			lnRecNo
		
		* See which column fired off this event.
		
		aevents(laEvents, 0)
		loHeader = laEvents[1, 1]
		if vartype(loHeader) = 'O'
		
		* Get the saved tag for the column.
		
			lcField = loHeader.Tag
		
		* If we're already sorted on this field (the header has a picture), we'll toggle
		* the sort order.
		
			if not empty(loHeader.Picture)
				llDescending = lower(justfname(loHeader.Picture)) == This.cDownImage
			else
		
		* Turn off sorting on other columns.
		
				for each loColumn in This.Columns foxobject
					for each loControl in loColumn.Controls foxobject
						if lower(loControl.BaseClass) == 'header' and ;
							not empty(loControl.Picture)
							llFoundColumn      = .T.
							loControl.Picture  = ''
							loControl.FontBold = .F.
							if loControl.BackColor = This.nHeaderSortedBackColor 
								loControl.BackColor = This.nHeaderSortableBackColor 
							endif loControl.BackColor = This.nHeaderSortedBackColor 
						endif lower(loControl.BaseClass) == 'header' ...
					next loControl
					if llFoundColumn
						exit
					endif llFoundColumn
				next loColumn
			endif not empty(loHeader.Picture)
		
		* If we have a field, sort on it; otherwise, turn off sorting. Note: there seems
		* to be a refresh issue here because even though the data is in the cursor, it's
		* not showing up in the grid after the sort; it looks like it's related to
		* AllowCellSelection.
		
			llAllowCellSelection    = This.AllowCellSelection
			This.AllowCellSelection = .F.
		
			lcTable = juststem(This.RecordSource)
			lnRecNo = recno(lcTable)
			do case
				case empty(lcField)
					set order to
				case llDescending
					set order to (lcField) descending in (lcTable)
				otherwise
					set order to (lcField) in (lcTable)
			endcase
			if between(lnRecNo, 1, reccount(lcTable))
				go lnRecNo in (lcTable)
			endif between(lnRecNo ...
			if not empty(lcField)
				loHeader.Picture   = iif(llDescending, This.cUpImage, This.cDownImage)
				loHeader.FontBold  = .T.
				loHeader.BackColor = This.nHeaderSortedBackColor 
			endif not empty(lcField)
		
			This.AllowCellSelection = llAllowCellSelection
			This.Refresh()
			keyboard '{CTRL+TAB}'
		endif vartype(loHeader) = 'O'
		
	ENDPROC

ENDDEFINE
